# Описание
Данный модуль входит в Node. Он необходим для установления TCP-соединения с другими модулями, а также для отправки и приёмки данных по TCP. Для сериализации используется QTextStream. Далее мы сами вручную определяем формат.

*Предлагаю пока не делать допюзначение, отмеченные (??? А нужно ли) - они дублируют в какой-то степени общую инфу каждого пакета

# Типы данных

В начале каждого сообщения идет два обязательных модуля, необходимых для северной части
1) Код программы quint16. Необходим для того, чтобы мы могли идентифицировать приходящий пакет, как пакет от нашей программы. Выбирается идентичным для всех передаваемых сообщений, например 132.
2) Суммарное количество передаваемых байт quint64. Данное количество НЕ УЧИТЫВАЕТ код программы и данное число.

Так, например, если необходимо передать 3 переменные типа double, то вводить необходимо следующие числа "132, 24, 1.2, 1.3, 1.4". Если передается пустое сообщение, то будет "132, 0" 
длину в байтах убоднее всего считать по длине QByteArray (получается независимо от передаваемого типа данных)

## DataInfo
Хранит в себе данные о передаваемых данных с клиента на избранный узел. Содержит в себе:
1) Идентификатор команды char, = 0xA0
2) Количество данных quint64. Содержит в себе количество данных, которые будут переданы на обработку

## DataPrep
Данные от избранного узла к служебному узлу
1) Идентификатор команды char, = 0xB0
2) Количество данных, которое будет передано от избранного узла quint64. Содержит в себе количество данных, которые будут переданы на обработку

## Formula
Хранит в себе
1) Идентификатор команды char, = 0xC0
2) (??? А нужно ли) Суммарное количество байт в формуле quint32. Содержит в себе последовательность байт, представляющую из себя формулу.
3) Далее идет последовательность байт формулы

## DataArray
Представляет из себя множество данных, посылаемых на обработку. Он должен заполнить данные и вызывать сигнал AddData
1) Код программы quint16. Необходим для того, чтобы мы могли идентифицировать приходящий пакет, как пакет от нашей программы
2) Идентификатор команды char, = 0xD0 (0b10100100). Также содержит идентификатор присылаемых данных: 0x00 (0b0000000) - char, 0x01 (0b0000001) - double. Далее идет побитовое сложение с идентификатором команды для определения типа. Для char будет 0xD0, для double будет 0xD1. В случае char разделителем для чисел являются переносы строки ('\n')
3) (??? А нужно ли) Количество данных в отосланной связке данных quint32. Обозначает количество элементов, которые были заложены в данный массив.
4) Далее идет последовательность данных. По умолчанию считаем, что мы отправляем и принимаем char

## DataModified
Представляет из себя множество данных, над которыми уже произвели операции. Вызывает сигнал DataModified
1) Идентификатор команды char, = 0xE0 (0b10100100). Идентификатор присылаемых данных: 0x00 (0b0000000) - char, 0x01 (0b0000001) - double. Далее идет побитовое сложение с идентификатором команды для определения типа. Для char будет 0xE0, для double будет 0xE1. В случае char разделителем для чисел являются переносы строки ('\n').
2) (??? А нужно ли) Количество данных в отосланной связке данных quint32. Обозначает количество элементов, которые были заложены в данный массив.
3) Далее идет последовательность данных. По умолчанию считаем, что мы отправляем и принимаем char


## ConnectionCheck
Пустой пакет. Содержит только данные, необходимые для проверки TCP-соединения.



# Устройство

## Переменные

QVector<QTcpSocket*> m_incomingSockets - содержит в себе сокеты подключенных узлов.

QTcpSocket* m_tempSocket - сокет, через который создаются другие сокеты, чтобы не инициализировать его постоянно

QMap<qintptr, QByteArray> data_storage - Хранит в себе данные, приходящие от других узлов. Нужно как-то сортировать данные, приходящие от разных узлов.

QTimer m_timerCheckExistedTcpConnections - Таймер, по истечению которого всем узлам будет высылаться пакет ConnectionCheck

## Сигналы

void signalSendDataToSerializer(QByteArray data) - высылает данные в сериализатор.

## Слоты

void incomingConnection(qintptr socketDescriptor) - стандартный слот для подключаемых сокетов.

void slotReadyRead() - обрабатывает новый пришедший пакет. Важно понимать, что приходящий пакет может приходить дробными частями. Это нужно обрабатывать

void slotCheckTcpConnections() - рассылает всем присоединенным узлам ConnectionCheck для проверки соединения. Подключается к тай
---
Есть Selected node - узел избранный клиентом, а есть KingNode - узел, который будет со всеми проводить benchmark.
---
При получении DataInfo, DataStorageProcessing иницализирует MapReduce.

1. MapReduce передает данные о том, какие данные будут переданы другим узлам по средству connection, прописанного внутри Node.

Есть два* варианта, как итерироваться по всем сокетам:
1) При добавлении в map<TCPSocket, pait<>> сразу отправляется в сериалайзер пара пар.
2) Или же только тогда весь map будет заполнен, дальше производится отдельный цикл по высыланию значений.

---
Мы 
